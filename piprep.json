{
  "version": "1",
  "pip_version": "25.0.1",
  "installed": [
    {
      "metadata": {
        "metadata_version": "2.1",
        "name": "absl-py",
        "version": "2.1.0",
        "summary": "Abseil Python Common Libraries, see https://github.com/abseil/abseil-py.",
        "description": "# Abseil Python Common Libraries\n\nThis repository is a collection of Python library code for building Python\napplications. The code is collected from Google's own Python code base, and has\nbeen extensively tested and used in production.\n\n## Features\n\n* Simple application startup\n* Distributed commandline flags system\n* Custom logging module with additional features\n* Testing utilities\n\n## Getting Started\n\n### Installation\n\nTo install the package, simply run:\n\n```bash\npip install absl-py\n```\n\nOr install from source:\n\n```bash\npython setup.py install\n```\n\n### Running Tests\n\nTo run Abseil tests, you can clone the git repo and run\n[bazel](https://bazel.build/):\n\n```bash\ngit clone https://github.com/abseil/abseil-py.git\ncd abseil-py\nbazel test absl/...\n```\n\n### Example Code\n\nPlease refer to\n[smoke_tests/sample_app.py](https://github.com/abseil/abseil-py/blob/main/smoke_tests/sample_app.py)\nas an example to get started.\n\n## Documentation\n\nSee the [Abseil Python Developer Guide](https://abseil.io/docs/python/).\n\n## Future Releases\n\nThe current repository includes an initial set of libraries for early adoption.\nMore components and interoperability with Abseil C++ Common Libraries\nwill come in future releases.\n\n## License\n\nThe Abseil Python library is licensed under the terms of the Apache\nlicense. See [LICENSE](LICENSE) for more information.\n",
        "description_content_type": "text/markdown",
        "home_page": "https://github.com/abseil/abseil-py",
        "author": "The Abseil Authors",
        "license": "Apache 2.0",
        "license_file": [
          "LICENSE",
          "AUTHORS"
        ],
        "classifier": [
          "Programming Language :: Python",
          "Programming Language :: Python :: 3",
          "Programming Language :: Python :: 3.7",
          "Programming Language :: Python :: 3.8",
          "Programming Language :: Python :: 3.9",
          "Programming Language :: Python :: 3.10",
          "Programming Language :: Python :: 3.11",
          "Programming Language :: Python :: 3.12",
          "Intended Audience :: Developers",
          "Topic :: Software Development :: Libraries :: Python Modules",
          "License :: OSI Approved :: Apache Software License",
          "Operating System :: OS Independent"
        ],
        "requires_python": ">=3.7"
      },
      "metadata_location": "C:\\Users\\shepa\\OneDrive\\8.0 Projects\\8.3 ProjectModelsEquinox\\EQUINRUN\\PythonLib\\venvwin1\\Lib\\site-packages\\absl_py-2.1.0.dist-info",
      "installer": "pip",
      "requested": false
    },
    {
      "metadata": {
        "metadata_version": "2.1",
        "name": "aniso8601",
        "version": "9.0.1",
        "platform": [
          "UNKNOWN"
        ],
        "summary": "A library for parsing ISO 8601 strings.",
        "description": "aniso8601\n=========\n\nAnother ISO 8601 parser for Python\n----------------------------------\n\nFeatures\n========\n* Pure Python implementation\n* Logical behavior\n\n  - Parse a time, get a `datetime.time <http://docs.python.org/3/library/datetime.html#datetime.time>`_\n  - Parse a date, get a `datetime.date <http://docs.python.org/3/library/datetime.html#datetime.date>`_\n  - Parse a datetime, get a `datetime.datetime <http://docs.python.org/3/library/datetime.html#datetime.datetime>`_\n  - Parse a duration, get a `datetime.timedelta <http://docs.python.org/3/library/datetime.html#datetime.timedelta>`_\n  - Parse an interval, get a tuple of dates or datetimes\n  - Parse a repeating interval, get a date or datetime `generator <https://wiki.python.org/moin/Generators>`_\n\n* UTC offset represented as fixed-offset tzinfo\n* Parser separate from representation, allowing parsing to different datetime representations (see `Builders`_)\n* No regular expressions\n\nInstallation\n============\n\nThe recommended installation method is to use pip::\n\n  $ pip install aniso8601\n\nAlternatively, you can download the source (git repository hosted at `Bitbucket <https://bitbucket.org/nielsenb/aniso8601>`_) and install directly::\n\n  $ python setup.py install\n\nUse\n===\n\nParsing datetimes\n-----------------\n\n*Consider* `datetime.datetime.fromisoformat <https://docs.python.org/3/library/datetime.html#datetime.datetime.fromisoformat>`_ *for basic ISO 8601 datetime parsing*\n\nTo parse a typical ISO 8601 datetime string::\n\n  >>> import aniso8601\n  >>> aniso8601.parse_datetime('1977-06-10T12:00:00Z')\n  datetime.datetime(1977, 6, 10, 12, 0, tzinfo=+0:00:00 UTC)\n\nAlternative delimiters can be specified, for example, a space::\n\n  >>> aniso8601.parse_datetime('1977-06-10 12:00:00Z', delimiter=' ')\n  datetime.datetime(1977, 6, 10, 12, 0, tzinfo=+0:00:00 UTC)\n\nUTC offsets are supported::\n\n  >>> aniso8601.parse_datetime('1979-06-05T08:00:00-08:00')\n  datetime.datetime(1979, 6, 5, 8, 0, tzinfo=-8:00:00 UTC)\n\nIf a UTC offset is not specified, the returned datetime will be naive::\n\n  >>> aniso8601.parse_datetime('1983-01-22T08:00:00')\n  datetime.datetime(1983, 1, 22, 8, 0)\n\nLeap seconds are currently not supported and attempting to parse one raises a :code:`LeapSecondError`::\n\n  >>> aniso8601.parse_datetime('2018-03-06T23:59:60')\n  Traceback (most recent call last):\n    File \"<stdin>\", line 1, in <module>\n    File \"/home/nielsenb/Jetfuse/aniso8601/aniso8601/aniso8601/time.py\", line 196, in parse_datetime\n      return builder.build_datetime(datepart, timepart)\n    File \"/home/nielsenb/Jetfuse/aniso8601/aniso8601/aniso8601/builders/python.py\", line 237, in build_datetime\n      cls._build_object(time))\n    File \"/home/nielsenb/Jetfuse/aniso8601/aniso8601/aniso8601/builders/__init__.py\", line 336, in _build_object\n      return cls.build_time(hh=parsetuple.hh, mm=parsetuple.mm,\n    File \"/home/nielsenb/Jetfuse/aniso8601/aniso8601/aniso8601/builders/python.py\", line 191, in build_time\n      hh, mm, ss, tz = cls.range_check_time(hh, mm, ss, tz)\n    File \"/home/nielsenb/Jetfuse/aniso8601/aniso8601/aniso8601/builders/__init__.py\", line 266, in range_check_time\n      raise LeapSecondError('Leap seconds are not supported.')\n  aniso8601.exceptions.LeapSecondError: Leap seconds are not supported.\n\nTo get the resolution of an ISO 8601 datetime string::\n\n  >>> aniso8601.get_datetime_resolution('1977-06-10T12:00:00Z') == aniso8601.resolution.TimeResolution.Seconds\n  True\n  >>> aniso8601.get_datetime_resolution('1977-06-10T12:00') == aniso8601.resolution.TimeResolution.Minutes\n  True\n  >>> aniso8601.get_datetime_resolution('1977-06-10T12') == aniso8601.resolution.TimeResolution.Hours\n  True\n\nNote that datetime resolutions map to :code:`TimeResolution` as a valid datetime must have at least one time member so the resolution mapping is equivalent.\n\nParsing dates\n-------------\n\n*Consider* `datetime.date.fromisoformat <https://docs.python.org/3/library/datetime.html#datetime.date.fromisoformat>`_ *for basic ISO 8601 date parsing*\n\nTo parse a date represented in an ISO 8601 string::\n\n  >>> import aniso8601\n  >>> aniso8601.parse_date('1984-04-23')\n  datetime.date(1984, 4, 23)\n\nBasic format is supported as well::\n\n  >>> aniso8601.parse_date('19840423')\n  datetime.date(1984, 4, 23)\n\nTo parse a date using the ISO 8601 week date format::\n\n  >>> aniso8601.parse_date('1986-W38-1')\n  datetime.date(1986, 9, 15)\n\nTo parse an ISO 8601 ordinal date::\n\n  >>> aniso8601.parse_date('1988-132')\n  datetime.date(1988, 5, 11)\n\nTo get the resolution of an ISO 8601 date string::\n\n  >>> aniso8601.get_date_resolution('1981-04-05') == aniso8601.resolution.DateResolution.Day\n  True\n  >>> aniso8601.get_date_resolution('1981-04') == aniso8601.resolution.DateResolution.Month\n  True\n  >>> aniso8601.get_date_resolution('1981') == aniso8601.resolution.DateResolution.Year\n  True\n\nParsing times\n-------------\n\n*Consider* `datetime.time.fromisoformat <https://docs.python.org/3/library/datetime.html#datetime.time.fromisoformat>`_ *for basic ISO 8601 time parsing*\n\nTo parse a time formatted as an ISO 8601 string::\n\n  >>> import aniso8601\n  >>> aniso8601.parse_time('11:31:14')\n  datetime.time(11, 31, 14)\n\nAs with all of the above, basic format is supported::\n\n  >>> aniso8601.parse_time('113114')\n  datetime.time(11, 31, 14)\n\nA UTC offset can be specified for times::\n\n  >>> aniso8601.parse_time('17:18:19-02:30')\n  datetime.time(17, 18, 19, tzinfo=-2:30:00 UTC)\n  >>> aniso8601.parse_time('171819Z')\n  datetime.time(17, 18, 19, tzinfo=+0:00:00 UTC)\n\nReduced accuracy is supported::\n\n  >>> aniso8601.parse_time('21:42')\n  datetime.time(21, 42)\n  >>> aniso8601.parse_time('22')\n  datetime.time(22, 0)\n\nA decimal fraction is always allowed on the lowest order element of an ISO 8601 formatted time::\n\n  >>> aniso8601.parse_time('22:33.5')\n  datetime.time(22, 33, 30)\n  >>> aniso8601.parse_time('23.75')\n  datetime.time(23, 45)\n\nThe decimal fraction can be specified with a comma instead of a full-stop::\n\n  >>> aniso8601.parse_time('22:33,5')\n  datetime.time(22, 33, 30)\n  >>> aniso8601.parse_time('23,75')\n  datetime.time(23, 45)\n\nLeap seconds are currently not supported and attempting to parse one raises a :code:`LeapSecondError`::\n\n  >>> aniso8601.parse_time('23:59:60')\n  Traceback (most recent call last):\n    File \"<stdin>\", line 1, in <module>\n    File \"/home/nielsenb/Jetfuse/aniso8601/aniso8601/aniso8601/time.py\", line 174, in parse_time\n      return builder.build_time(hh=hourstr, mm=minutestr, ss=secondstr, tz=tz)\n    File \"/home/nielsenb/Jetfuse/aniso8601/aniso8601/aniso8601/builders/python.py\", line 191, in build_time\n      hh, mm, ss, tz = cls.range_check_time(hh, mm, ss, tz)\n    File \"/home/nielsenb/Jetfuse/aniso8601/aniso8601/aniso8601/builders/__init__.py\", line 266, in range_check_time\n      raise LeapSecondError('Leap seconds are not supported.')\n  aniso8601.exceptions.LeapSecondError: Leap seconds are not supported.\n\nTo get the resolution of an ISO 8601 time string::\n\n  >>> aniso8601.get_time_resolution('11:31:14') == aniso8601.resolution.TimeResolution.Seconds\n  True\n  >>> aniso8601.get_time_resolution('11:31') == aniso8601.resolution.TimeResolution.Minutes\n  True\n  >>> aniso8601.get_time_resolution('11') == aniso8601.resolution.TimeResolution.Hours\n  True\n\nParsing durations\n-----------------\n\nTo parse a duration formatted as an ISO 8601 string::\n\n  >>> import aniso8601\n  >>> aniso8601.parse_duration('P1Y2M3DT4H54M6S')\n  datetime.timedelta(428, 17646)\n\nReduced accuracy is supported::\n\n  >>> aniso8601.parse_duration('P1Y')\n  datetime.timedelta(365)\n\nA decimal fraction is allowed on the lowest order element::\n\n  >>> aniso8601.parse_duration('P1YT3.5M')\n  datetime.timedelta(365, 210)\n\nThe decimal fraction can be specified with a comma instead of a full-stop::\n\n  >>> aniso8601.parse_duration('P1YT3,5M')\n  datetime.timedelta(365, 210)\n\nParsing a duration from a combined date and time is supported as well::\n\n  >>> aniso8601.parse_duration('P0001-01-02T01:30:05')\n  datetime.timedelta(397, 5405)\n\nTo get the resolution of an ISO 8601 duration string::\n\n  >>> aniso8601.get_duration_resolution('P1Y2M3DT4H54M6S') == aniso8601.resolution.DurationResolution.Seconds\n  True\n  >>> aniso8601.get_duration_resolution('P1Y2M3DT4H54M') == aniso8601.resolution.DurationResolution.Minutes\n  True\n  >>> aniso8601.get_duration_resolution('P1Y2M3DT4H') == aniso8601.resolution.DurationResolution.Hours\n  True\n  >>> aniso8601.get_duration_resolution('P1Y2M3D') == aniso8601.resolution.DurationResolution.Days\n  True\n  >>> aniso8601.get_duration_resolution('P1Y2M') == aniso8601.resolution.DurationResolution.Months\n  True\n  >>> aniso8601.get_duration_resolution('P1Y') == aniso8601.resolution.DurationResolution.Years\n  True\n\nThe default :code:`PythonTimeBuilder` assumes years are 365 days, and months are 30 days. Where calendar level accuracy is required, a `RelativeTimeBuilder <https://bitbucket.org/nielsenb/relativetimebuilder>`_ can be used, see also `Builders`_.\n\nParsing intervals\n-----------------\n\nTo parse an interval specified by a start and end::\n\n  >>> import aniso8601\n  >>> aniso8601.parse_interval('2007-03-01T13:00:00/2008-05-11T15:30:00')\n  (datetime.datetime(2007, 3, 1, 13, 0), datetime.datetime(2008, 5, 11, 15, 30))\n\nIntervals specified by a start time and a duration are supported::\n\n  >>> aniso8601.parse_interval('2007-03-01T13:00:00Z/P1Y2M10DT2H30M')\n  (datetime.datetime(2007, 3, 1, 13, 0, tzinfo=+0:00:00 UTC), datetime.datetime(2008, 5, 9, 15, 30, tzinfo=+0:00:00 UTC))\n\nA duration can also be specified by a duration and end time::\n\n  >>> aniso8601.parse_interval('P1M/1981-04-05')\n  (datetime.date(1981, 4, 5), datetime.date(1981, 3, 6))\n\nNotice that the result of the above parse is not in order from earliest to latest. If sorted intervals are required, simply use the :code:`sorted` keyword as shown below::\n\n  >>> sorted(aniso8601.parse_interval('P1M/1981-04-05'))\n  [datetime.date(1981, 3, 6), datetime.date(1981, 4, 5)]\n\nThe end of an interval is returned as a datetime when required to maintain the resolution specified by a duration, even if the duration start is given as a date::\n\n  >>> aniso8601.parse_interval('2014-11-12/PT4H54M6.5S')\n  (datetime.date(2014, 11, 12), datetime.datetime(2014, 11, 12, 4, 54, 6, 500000))\n  >>> aniso8601.parse_interval('2007-03-01/P1.5D')\n  (datetime.date(2007, 3, 1), datetime.datetime(2007, 3, 2, 12, 0))\n\nConcise representations are supported::\n\n  >>> aniso8601.parse_interval('2020-01-01/02')\n  (datetime.date(2020, 1, 1), datetime.date(2020, 1, 2))\n  >>> aniso8601.parse_interval('2007-12-14T13:30/15:30')\n  (datetime.datetime(2007, 12, 14, 13, 30), datetime.datetime(2007, 12, 14, 15, 30))\n  >>> aniso8601.parse_interval('2008-02-15/03-14')\n  (datetime.date(2008, 2, 15), datetime.date(2008, 3, 14))\n  >>> aniso8601.parse_interval('2007-11-13T09:00/15T17:00')\n  (datetime.datetime(2007, 11, 13, 9, 0), datetime.datetime(2007, 11, 15, 17, 0))\n\nRepeating intervals are supported as well, and return a `generator <https://wiki.python.org/moin/Generators>`_::\n\n  >>> aniso8601.parse_repeating_interval('R3/1981-04-05/P1D')\n  <generator object _date_generator at 0x7fd800d3b320>\n  >>> list(aniso8601.parse_repeating_interval('R3/1981-04-05/P1D'))\n  [datetime.date(1981, 4, 5), datetime.date(1981, 4, 6), datetime.date(1981, 4, 7)]\n\nRepeating intervals are allowed to go in the reverse direction::\n\n  >>> list(aniso8601.parse_repeating_interval('R2/PT1H2M/1980-03-05T01:01:00'))\n  [datetime.datetime(1980, 3, 5, 1, 1), datetime.datetime(1980, 3, 4, 23, 59)]\n\nUnbounded intervals are also allowed (Python 2)::\n\n  >>> result = aniso8601.parse_repeating_interval('R/PT1H2M/1980-03-05T01:01:00')\n  >>> result.next()\n  datetime.datetime(1980, 3, 5, 1, 1)\n  >>> result.next()\n  datetime.datetime(1980, 3, 4, 23, 59)\n\nor for Python 3::\n\n  >>> result = aniso8601.parse_repeating_interval('R/PT1H2M/1980-03-05T01:01:00')\n  >>> next(result)\n  datetime.datetime(1980, 3, 5, 1, 1)\n  >>> next(result)\n  datetime.datetime(1980, 3, 4, 23, 59)\n\nNote that you should never try to convert a generator produced by an unbounded interval to a list::\n\n  >>> list(aniso8601.parse_repeating_interval('R/PT1H2M/1980-03-05T01:01:00'))\n  Traceback (most recent call last):\n    File \"<stdin>\", line 1, in <module>\n    File \"/home/nielsenb/Jetfuse/aniso8601/aniso8601/aniso8601/builders/python.py\", line 560, in _date_generator_unbounded\n      currentdate += timedelta\n  OverflowError: date value out of range\n\nTo get the resolution of an ISO 8601 interval string::\n\n  >>> aniso8601.get_interval_resolution('2007-03-01T13:00:00/2008-05-11T15:30:00') == aniso8601.resolution.IntervalResolution.Seconds\n  True\n  >>> aniso8601.get_interval_resolution('2007-03-01T13:00/2008-05-11T15:30') == aniso8601.resolution.IntervalResolution.Minutes\n  True\n  >>> aniso8601.get_interval_resolution('2007-03-01T13/2008-05-11T15') == aniso8601.resolution.IntervalResolution.Hours\n  True\n  >>> aniso8601.get_interval_resolution('2007-03-01/2008-05-11') == aniso8601.resolution.IntervalResolution.Day\n  True\n  >>> aniso8601.get_interval_resolution('2007-03/P1Y') == aniso8601.resolution.IntervalResolution.Month\n  True\n  >>> aniso8601.get_interval_resolution('2007/P1Y') == aniso8601.resolution.IntervalResolution.Year\n  True\n\nAnd for repeating ISO 8601 interval strings::\n\n  >>> aniso8601.get_repeating_interval_resolution('R3/1981-04-05/P1D') == aniso8601.resolution.IntervalResolution.Day\n  True\n  >>> aniso8601.get_repeating_interval_resolution('R/PT1H2M/1980-03-05T01:01:00') == aniso8601.resolution.IntervalResolution.Seconds\n  True\n\nBuilders\n========\n\nBuilders can be used to change the output format of a parse operation. All parse functions have a :code:`builder` keyword argument which accepts a builder class.\n\nTwo builders are included. The :code:`PythonTimeBuilder` (the default) in the :code:`aniso8601.builders.python` module, and the :code:`TupleBuilder` which returns the parse result as a corresponding named tuple and is located in the :code:`aniso8601.builders` module.\n\nInformation on writing a builder can be found in `BUILDERS </BUILDERS.rst>`_.\n\nThe following builders are available as separate projects:\n\n* `RelativeTimeBuilder <https://bitbucket.org/nielsenb/relativetimebuilder>`_ supports parsing to `datetutil relativedelta types <https://dateutil.readthedocs.io/en/stable/relativedelta.html>`_ for calendar level accuracy\n* `AttoTimeBuilder <https://bitbucket.org/nielsenb/attotimebuilder>`_ supports parsing directly to `attotime attodatetime and attotimedelta types <https://bitbucket.org/nielsenb/attotime>`_ which support sub-nanosecond precision\n* `NumPyTimeBuilder <https://bitbucket.org/nielsenb/numpytimebuilder>`_ supports parsing directly to `NumPy datetime64 and timedelta64 types <https://docs.scipy.org/doc/numpy/reference/arrays.datetime.html>`_\n\nTupleBuilder\n------------\n\nThe :code:`TupleBuilder` returns parse results as `named tuples <https://docs.python.org/3/library/collections.html#collections.namedtuple>`_. It is located in the :code:`aniso8601.builders` module.\n\nDatetimes\n^^^^^^^^^\n\nParsing a datetime returns a :code:`DatetimeTuple` containing :code:`Date` and :code:`Time` tuples . The date tuple contains the following parse components: :code:`YYYY`, :code:`MM`, :code:`DD`, :code:`Www`, :code:`D`, :code:`DDD`. The time tuple contains the following parse components :code:`hh`, :code:`mm`, :code:`ss`, :code:`tz`, where :code:`tz` itself is a tuple with the following components :code:`negative`, :code:`Z`, :code:`hh`, :code:`mm`, :code:`name` with :code:`negative` and :code:`Z` being booleans::\n\n  >>> import aniso8601\n  >>> from aniso8601.builders import TupleBuilder\n  >>> aniso8601.parse_datetime('1977-06-10T12:00:00', builder=TupleBuilder)\n  Datetime(date=Date(YYYY='1977', MM='06', DD='10', Www=None, D=None, DDD=None), time=Time(hh='12', mm='00', ss='00', tz=None))\n  >>> aniso8601.parse_datetime('1979-06-05T08:00:00-08:00', builder=TupleBuilder)\n  Datetime(date=Date(YYYY='1979', MM='06', DD='05', Www=None, D=None, DDD=None), time=Time(hh='08', mm='00', ss='00', tz=Timezone(negative=True, Z=None, hh='08', mm='00', name='-08:00')))\n\nDates\n^^^^^\n\nParsing a date returns a :code:`DateTuple` containing the following parse components: :code:`YYYY`, :code:`MM`, :code:`DD`, :code:`Www`, :code:`D`, :code:`DDD`::\n\n  >>> import aniso8601\n  >>> from aniso8601.builders import TupleBuilder\n  >>> aniso8601.parse_date('1984-04-23', builder=TupleBuilder)\n  Date(YYYY='1984', MM='04', DD='23', Www=None, D=None, DDD=None)\n  >>> aniso8601.parse_date('1986-W38-1', builder=TupleBuilder)\n  Date(YYYY='1986', MM=None, DD=None, Www='38', D='1', DDD=None)\n  >>> aniso8601.parse_date('1988-132', builder=TupleBuilder)\n  Date(YYYY='1988', MM=None, DD=None, Www=None, D=None, DDD='132')\n\nTimes\n^^^^^\n\nParsing a time returns a :code:`TimeTuple` containing following parse components: :code:`hh`, :code:`mm`, :code:`ss`, :code:`tz`, where :code:`tz` is a :code:`TimezoneTuple` with the following components :code:`negative`, :code:`Z`, :code:`hh`, :code:`mm`, :code:`name`, with :code:`negative` and :code:`Z` being booleans::\n\n  >>> import aniso8601\n  >>> from aniso8601.builders import TupleBuilder\n  >>> aniso8601.parse_time('11:31:14', builder=TupleBuilder)\n  Time(hh='11', mm='31', ss='14', tz=None)\n  >>> aniso8601.parse_time('171819Z', builder=TupleBuilder)\n  Time(hh='17', mm='18', ss='19', tz=Timezone(negative=False, Z=True, hh=None, mm=None, name='Z'))\n  >>> aniso8601.parse_time('17:18:19-02:30', builder=TupleBuilder)\n  Time(hh='17', mm='18', ss='19', tz=Timezone(negative=True, Z=None, hh='02', mm='30', name='-02:30'))\n\nDurations\n^^^^^^^^^\n\nParsing a duration returns a :code:`DurationTuple` containing the following parse components: :code:`PnY`, :code:`PnM`, :code:`PnW`, :code:`PnD`, :code:`TnH`, :code:`TnM`, :code:`TnS`::\n\n  >>> import aniso8601\n  >>> from aniso8601.builders import TupleBuilder\n  >>> aniso8601.parse_duration('P1Y2M3DT4H54M6S', builder=TupleBuilder)\n  Duration(PnY='1', PnM='2', PnW=None, PnD='3', TnH='4', TnM='54', TnS='6')\n  >>> aniso8601.parse_duration('P7W', builder=TupleBuilder)\n  Duration(PnY=None, PnM=None, PnW='7', PnD=None, TnH=None, TnM=None, TnS=None)\n\nIntervals\n^^^^^^^^^\n\nParsing an interval returns an :code:`IntervalTuple` containing the following parse components: :code:`start`, :code:`end`, :code:`duration`, :code:`start` and :code:`end` may both be datetime or date tuples, :code:`duration` is a duration tuple::\n\n  >>> import aniso8601\n  >>> from aniso8601.builders import TupleBuilder\n  >>> aniso8601.parse_interval('2007-03-01T13:00:00/2008-05-11T15:30:00', builder=TupleBuilder)\n  Interval(start=Datetime(date=Date(YYYY='2007', MM='03', DD='01', Www=None, D=None, DDD=None), time=Time(hh='13', mm='00', ss='00', tz=None)), end=Datetime(date=Date(YYYY='2008', MM='05', DD='11', Www=None, D=None, DDD=None), time=Time(hh='15', mm='30', ss='00', tz=None)), duration=None)\n  >>> aniso8601.parse_interval('2007-03-01T13:00:00Z/P1Y2M10DT2H30M', builder=TupleBuilder)\n  Interval(start=Datetime(date=Date(YYYY='2007', MM='03', DD='01', Www=None, D=None, DDD=None), time=Time(hh='13', mm='00', ss='00', tz=Timezone(negative=False, Z=True, hh=None, mm=None, name='Z'))), end=None, duration=Duration(PnY='1', PnM='2', PnW=None, PnD='10', TnH='2', TnM='30', TnS=None))\n  >>> aniso8601.parse_interval('P1M/1981-04-05', builder=TupleBuilder)\n  Interval(start=None, end=Date(YYYY='1981', MM='04', DD='05', Www=None, D=None, DDD=None), duration=Duration(PnY=None, PnM='1', PnW=None, PnD=None, TnH=None, TnM=None, TnS=None))\n\nA repeating interval returns a :code:`RepeatingIntervalTuple` containing the following parse components: :code:`R`, :code:`Rnn`, :code:`interval`, where :code:`R` is a boolean, :code:`True` for an unbounded interval, :code:`False` otherwise.::\n\n  >>> aniso8601.parse_repeating_interval('R3/1981-04-05/P1D', builder=TupleBuilder)\n  RepeatingInterval(R=False, Rnn='3', interval=Interval(start=Date(YYYY='1981', MM='04', DD='05', Www=None, D=None, DDD=None), end=None, duration=Duration(PnY=None, PnM=None, PnW=None, PnD='1', TnH=None, TnM=None, TnS=None)))\n  >>> aniso8601.parse_repeating_interval('R/PT1H2M/1980-03-05T01:01:00', builder=TupleBuilder)\n  RepeatingInterval(R=True, Rnn=None, interval=Interval(start=None, end=Datetime(date=Date(YYYY='1980', MM='03', DD='05', Www=None, D=None, DDD=None), time=Time(hh='01', mm='01', ss='00', tz=None)), duration=Duration(PnY=None, PnM=None, PnW=None, PnD=None, TnH='1', TnM='2', TnS=None)))\n\nDevelopment\n===========\n\nSetup\n-----\n\nIt is recommended to develop using a `virtualenv <https://virtualenv.pypa.io/en/stable/>`_.\n\nInside a virtualenv, development dependencies can be installed automatically::\n\n  $ pip install -e .[dev]\n\n`pre-commit <https://pre-commit.com/>`_ is used for managing pre-commit hooks::\n\n  $ pre-commit install\n\nTo run the pre-commit hooks manually::\n\n  $ pre-commit run --all-files\n\nTests\n-----\n\nTests can be run using the `unittest testing framework <https://docs.python.org/3/library/unittest.html>`_::\n\n  $ python -m unittest discover aniso8601\n\nContributing\n============\n\naniso8601 is an open source project hosted on `Bitbucket <https://bitbucket.org/nielsenb/aniso8601>`_.\n\nAny and all bugs are welcome on our `issue tracker <https://bitbucket.org/nielsenb/aniso8601/issues>`_.\nOf particular interest are valid ISO 8601 strings that don't parse, or invalid ones that do. At a minimum,\nbug reports should include an example of the misbehaving string, as well as the expected result. Of course\npatches containing unit tests (or fixed bugs) are welcome!\n\nReferences\n==========\n\n* `ISO 8601:2004(E) <http://dotat.at/tmp/ISO_8601-2004_E.pdf>`_ (Caution, PDF link)\n* `Wikipedia article on ISO 8601 <http://en.wikipedia.org/wiki/Iso8601>`_\n* `Discussion on alternative ISO 8601 parsers for Python <https://groups.google.com/forum/#!topic/comp.lang.python/Q2w4R89Nq1w>`_\n\n\n",
        "description_content_type": "text/x-rst",
        "keywords": [
          "iso8601",
          "parser"
        ],
        "home_page": "https://bitbucket.org/nielsenb/aniso8601",
        "author": "Brandon Nielsen",
        "author_email": "nielsenb@jetfuse.net",
        "license": "UNKNOWN",
        "classifier": [
          "Development Status :: 5 - Production/Stable",
          "Intended Audience :: Developers",
          "License :: OSI Approved :: BSD License",
          "Operating System :: OS Independent",
          "Programming Language :: Python",
          "Programming Language :: Python :: 2",
          "Programming Language :: Python :: 2.7",
          "Programming Language :: Python :: 3",
          "Programming Language :: Python :: 3.4",
          "Programming Language :: Python :: 3.5",
          "Programming Language :: Python :: 3.6",
          "Programming Language :: Python :: 3.7",
          "Programming Language :: Python :: 3.8",
          "Programming Language :: Python :: 3.9",
          "Topic :: Software Development :: Libraries :: Python Modules"
        ],
        "requires_dist": [
          "black ; extra == 'dev'",
          "coverage ; extra == 'dev'",
          "isort ; extra == 'dev'",
          "pre-commit ; extra == 'dev'",
          "pyenchant ; extra == 'dev'",
          "pylint ; extra == 'dev'"
        ],
        "project_url": [
          "Documentation, https://aniso8601.readthedocs.io/",
          "Source, https://bitbucket.org/nielsenb/aniso8601",
          "Tracker, https://bitbucket.org/nielsenb/aniso8601/issues"
        ],
        "provides_extra": [
          "dev"
        ]
      },
      "metadata_location": "C:\\Users\\shepa\\OneDrive\\8.0 Projects\\8.3 ProjectModelsEquinox\\EQUINRUN\\PythonLib\\venvwin1\\Lib\\site-packages\\aniso8601-9.0.1.dist-info",
      "installer": "pip",
      "requested": true
    },
    {
      "metadata": {
        "metadata_version": "2.1",
        "name": "anyascii",
        "version": "0.3.2",
        "summary": "Unicode to ASCII transliteration",
        "description": 